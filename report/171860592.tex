\documentclass[a4paper,UTF8]{article}
\usepackage{ctex}
\usepackage[margin=1.25in]{geometry}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage{color}
\usepackage{listings}
\usepackage{cite}
% \usepackage[thmmarks, amsmath, thref]{ntheorem}
\theoremstyle{definition}
\newtheorem*{solution}{Solution}
\newtheorem*{prove}{Proof}
\usepackage{multirow}
\usepackage{url}
\usepackage[colorlinks,urlcolor=blue]{hyperref}
\usepackage{enumerate}


\renewcommand\refname{参考文献}
\setCJKmainfont{SimHei}

\setmonofont{Consolas}
\definecolor{mygreen}{rgb}{0,0.6,0}  
\definecolor{mygray}{rgb}{0.5,0.5,0.5}  
\definecolor{mymauve}{rgb}{0.58,0,0.82} 

\lstset{ %  
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}  
  basicstyle=\ttfamily\footnotesize,
  % basicstyle=\footnotesize,        % the size of the fonts that are used for the code  
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace  
  breaklines=true,                 % sets automatic line breaking  
  captionpos=bl,                    % sets the caption-position to bottom  
  commentstyle=\color{mygreen},    % comment style  
  deletekeywords={...},            % if you want to delete keywords from the given language  
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code  
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8  
  frame=single,                    % adds a frame around the code  
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)  
  keywordstyle=\color{blue},       % keyword style  
  %language=Python,                 % the language of the code  
  morekeywords={*,...},            % if you want to add more keywords to the set  
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)  
  numbersep=12pt,                   % how far the line-numbers are from the code  
  numberstyle=\footnotesize\color{mygray}, % the style that is used for the line-numbers  
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))  
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'  
  showstringspaces=false,          % underline spaces within strings only  
  showtabs=false,                  % show tabs within strings adding particular underscores  
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered  
  stringstyle=\color{orange},     % string literal style  
  tabsize=2,                       % sets default tabsize to 2 spaces  
  %title=myPython.py                   % show the filename of files included with \lstinputlisting; also try caption instead of title  
}  




%--

%--
\begin{document}
\title{\textbf{《计算机图形学》3月报告}}
\author{171860592，吕云哲，\href{mailto:maxwell.lyu@foxmail.com}{maxwell.lyu@foxmail.com}}
\maketitle

\section{综述}
\subsection{进度综述}
  本进度报告为持续更新版, 之后的进度会直接在该报告中添加, 直到实验正式结束, 将正式转为项目报告\\
  当前的进度如下: 
  \begin{itemize}
    \item cg\_algorithms.py: 完成全部功能
    \item cg\_cli.py: 完成全部功能
    \item cg\_gui.py: 完成全部必要功能, 可选功能持续添加中, 已经添加的额外功能
    \begin{itemize}
      \item [功能]将画布导出为PNG图片
      \item [功能]将画布导出为绘图命令, 兼容cg\_cli
      \item [功能]单行输入, 用cg\_cli命令绘图, 或将选中图元解析为命令
      \item [功能]操作历史记录, 撤销和重做
      \item [功能]控件选取颜色
      \item [交互]点击图元进行选中
      \item [交互]退出, 重置画布加入确认弹窗, 防止误操作
      \item [交互]根据选中的对象, 智能禁用不适用的操作, 例如椭圆不支持旋转
      \item [界面]优美界面, 设计风格参考Android 4.0 Holo Dark
      \item [界面]启动时显示Splash, 展现产品形象
      \item [界面]2种按钮样式, 4种按钮状态
    \end{itemize}
  \end{itemize}
\subsection{项目综述}
  本项目为2020年春季计算机图形学课程的课程设计, 以Python3为编写语言, 旨在通过实际的项目实践, 熟悉本课程教学内容, 掌握重点的图形绘制算法.\\
  项目的成果包括以下3个部分
  \begin{itemize}
    \item cg\_algorithms.py: 所有需要实现的算法
    \item cg\_cli.py: 基于算法, 构建命令行程序, 对算法进行应用于展示
    \item cg\_gui.py: 基于算法, 使用Pyqt5框架, 对算法进行应用与展示
  \end{itemize}
\section{算法介绍}
\subsection{DDA算法绘制线段}
\begin{itemize}
  \item 算法介绍\\
  DDA数值差分分析 (digital differential analyzer), 通过解直线的微分方程式, 进行直线的光栅化. 算法首先选取直线在两个方向的增量$\Delta x$和$\Delta y$中较大的一个, 作为一个光栅单位, 沿此方向扫描. 其利用了光栅扫描显示特性：像素列阵为屏幕单位网格, 通过离散取样, 使用x或y方向单位增量间隔, 逐步计算沿线路径各像素位置\\
  \item 算法流程
  \begin{enumerate}
    \item 首先计算x与y方向的增量, 此处与课堂教学内容不同, 可以避免由于直线垂直带来的麻烦
    \item 之后对直线退化为点的情况进行单独处理, 判断增量是否为0, 防止除零
    \item 分别计算两个方向的增量, 该步亦是对课堂教学内容的简化, 推导如下:\\
    当斜率$0\leq m\leq 1$
    \begin{align}
      \begin{split}
        length &= \max(\Delta x, \Delta y) = \Delta x\\
        x_{k+1} &= x_k + 1 = x_k + \frac{\Delta x}{\Delta x} = x_k + \frac{\Delta x}{length} = x_k + dx\\
        y_{k+1} &= y_k + m = y_k + \frac{\Delta y}{\Delta x} = y_k + \frac{\Delta y}{length} = y_k + dy
      \end{split}
    \end{align}
    当斜率$m > 1$
    \begin{align}
      \begin{split}
        length &= \max(\Delta x, \Delta y) = \Delta y\\
        x_{k+1} &= x_k + 1 = x_k + \frac{\Delta y}{\Delta y} = x_k + \frac{\Delta x}{length} = x_k + dx\\
        y_{k+1} &= y_k + \frac{1}{m} = y_k + \frac{\Delta x}{\Delta y} = y_k + \frac{\Delta y}{length} = y_k + dy
      \end{split}
    \end{align}
    因此不必费心处理沿x还是沿y递增, 直接使用下式进行迭代即可\cite{rog_2002}
    \begin{align}
      \begin{split}
        x_{k+1} &= x_k + dx\\
        y_{k+1} &= y_k + dy
      \end{split}
    \end{align}
    \item 不断递增, 并取整, 直接使用python自带的round函数进行
  \end{enumerate}
  
  

  \item 我的理解: DDA和最朴素的直线点斜式方程带入方法相比, 基本原理是一致的, 做出的改变在于节约了乘法, 其理解难度较低, 效率很高. 实际绘制时, 可以明显注意到效率高于Bresenham, 在后文绘制多边形时会详细讲解
  \item 相关代码
  \begin{lstlisting}[language={Python}]  
    elif algorithm == 'DDA':
        length = max(abs(y1 - y0), abs(x1 - x0))
        if length == 0: 
            result.append((x0, y0))
        else:
            dx = (x1 - x0) / length
            dy = (y1 - y0) / length
            i = 1
            x, y = x0, y0
            while i <= length:
                result.append((round(x), round(y)))
                x += dx
                y += dy
                i += 1\end{lstlisting}
\end{itemize}
\subsection{Bresenham算法绘制线段}
\begin{itemize}
  \item 算法介绍\\
  由Bresenham提出的算法, 采用整数增量运算, 精确而有效的光栅设备线生成算法, 也可用于其他曲线显示. 根据光栅显示原理, 离散取样过程中, 每一放样位置上只可能有2个像素接近于路径, 其核心部分为\begin{itemize}
    \item 设计整型参量, 用于判断候选像素与实际线路径之间的偏移关系
    \item 检测参量符号, 据此选取离路径近的像素
  \end{itemize}
  \item 算法流程\\
  课堂教学仅给出了第一八分之一圆域的绘制方法, 我参考《计算机图形学的算法基础》, 构造了任意方向的绘制算法
  \begin{enumerate}
    \item 准备工作, 计算$\Delta x$和$\Delta y$, 根据点的相对位置确认x与y在绘制时的增减情况, 并初始化x与y为绘制起点
    \item 判断斜率绝对值, 若超过1, 则交换dx和dy, 并在之后的流程中交换x与y的增减操作, 以下以第一八分之一圆域为例
    \item 初始化参量e为$2\Delta y-\Delta x$
    \item 重复$\Delta x$次\begin{enumerate}
      \item 绘制$(x,y)$
      \item 若e大于0, 说明绘制点$(x_{k+1}, y_{k+1})$, 此处使用s2, 可以同时解决负斜率和0斜率的问题, 因为python的sign函数对正数, 0, 负数分别返回1, 0, -1, 这步处理是很巧妙的. 更新e, 仅减去$2\Delta x$
      \item 若否, 说明绘制点$(x_{k+1}, y_{k+1})$, 该部分不改变y值和e值
      \item 更新x, 同样使用sign, 处理了无穷斜率的情况, 同时将e加上$2\Delta y$, 与前一步的$-2\Delta x$配合, 完成更新
    \end{enumerate}
    \item 最后, 需要将结束点加上
  \end{enumerate}
  \item 我的理解\begin{itemize}
    \item 算法本身有着很强的拓展性, 只要定义一个合适的决策参量, 该算法能够绘制很多其他的曲线
    \item 编写时, 我遇到的最大困难是耦合代码, 8个圆域, 还有水平垂直等特殊情况. 比较容易想到的方法, 是处理斜率超过1, 只需添加一个交换指示变量即可. 而使用sign函数将水平垂直和正负斜率均处理掉\cite{rog_2002}, 简直是绝妙的设计, 我十分佩服《计算机图形学的算法基础》一书的作者
  \end{itemize}
  \item 相关代码
  \begin{lstlisting}[language={Python}]     
    elif algorithm == 'Bresenham':
        x = x0
        y = y0
        dx = abs(x1 - x0)
        dy = abs(y1 - y0)
        s1 = sign(x1 - x0)
        s2 = sign(y1 - y0)
        interchange = (dy > dx)
        if interchange:
            dx, dy = dy, dx
        e = 2 * dy - dx
        for i in range(dx):
            result.append((x, y))
            if e > 0:
                if interchange:
                    x += s1
                else:
                    y += s2
                e = e - 2 * dx
            if interchange:
                y = y + s2
            else:
                x = x + s1
            e = e + 2 * dy
        result.append((x1, y1))\end{lstlisting}
\end{itemize}
\subsection{DDA算法绘制多边形/Bresenham算法绘制多边形}
\begin{itemize}
  \item 算法介绍\\
  绘制多边形, 其实就是绘制线段, 对于给定的n顶点列表, 按序连接顶点, 将得到n条线段. 用给定的算法对这些线段进行光栅化, 即得到绘制的多边形
  \item 算法流程
  \begin{enumerate}
    \item 处理2顶点的情况: 若顶点只有2个, 将不能构成有效的多边形, 此时按照线段处理, 用指定的算法绘制两点间的线段
    \item 对于至少3顶点的顶点列表, 利用Python列表循环访问的特性, 使用下标-1访问使用一个简单的for语句就能按序栅格化所有的线段
  \end{enumerate}
  \item 我的理解: 本次实验的多边形绘制相对简单, 因为实验要求并未规定是凸多边形, 因此我默认用户提供的顶点是按序合法的, 因此不进行凸包等运算, 按序连接即宣告完成
  \item 相关代码
  \begin{lstlisting}[language={Python}] 
    if len(p_list) == 2:
        return draw_line([p_list[0], p_list[1]], algorithm)
    result = []
    for i in range(len(p_list)):
        line = draw_line([p_list[i - 1], p_list[i]], algorithm)
        result += line
    return result\end{lstlisting}
\end{itemize}
\subsection{中点圆生成算法绘制椭圆}
\begin{itemize}
  \item 算法介绍\begin{itemize}
    \item 椭圆: 到2定点距离之和等于常数的点集
    \item 标准位置椭圆: 长轴和短轴平行于x轴和y轴
    \item 实验要求绘制的椭圆为标准位置椭圆, 并且不要求旋转, 因此\begin{itemize}
      \item 利用平移, 绘制以原点为中心的椭圆, 并将其平移到指定位置
      \item 利用对称性, 在平移的基础上, 只需绘制第一象限的1/4椭圆, 之后进行变换即可
    \end{itemize}
    \item 栅格化过程采取Bresenham算法的思路, 构造决策参数, 通过判断2个待选点的中点处, 决策函数的符号, 对下一位置的光栅化结果进行选取, 并迭代决策参数
    \item 另一个重点是, 椭圆在第一象限存在一点, 其斜率为-1. 以该点进行划分, 类似Bresenham算法绘制线段时遇到的, 斜率不同时分别沿x与y递增, 可以将椭圆分为两部分进行绘制\cite{sun_2006}. 计算该点的过程如下\begin{itemize}
      \item 当斜率为-1时, 有$$ -1$$
      \item 根据椭圆方程, 可构造$$df(x,y) = d(b^2x^2 + a^2y^2-a^2b^2) = 2b^2xdx + 2a^2ydy = d(0)  = 0$$
      \item 于是$$\frac{dy}{dx} = -\frac{b^2x}{a^2y}$$
      \item 故可以用$b^2x$与$a^2y$的相对大小作为条件, 区别区域1,2. 我的实现中, 斜率小于-1的区域标为区域1, 与课程PPT中的编号相反
    \end{itemize}
  \end{itemize}
  \item 算法流程
  \begin{enumerate}
    \item 框架代码指定参数为椭圆的矩形包围框左上角和右下角顶点坐标, 因此需要首先根据给定的参数, 计算出符合中点圆生成算法的参数, 包括椭圆的半长轴a, 半短轴b, 以及进行平移变换需要的中心点坐标$center = (x_c,y_c)$
    \item 参考\cite{rog_2002}, 首先计算一些辅助量, 以便加速之后的计算, 并使得算式更加简洁
    \item 设定初始点为$(a,0)$, 作为起始点, 并计算初始决策参数$$p1_0 = 2b^2x(x-1)+b^2/2+2a^2(1-b^2)$$
    \item 当$b^2x>a^2y$时, 为区域1, 逆时针移动, 不断进行如下迭代\begin{enumerate}
    \item 绘制点$(x,y)$
      \item 若$p1_k<0$, 选择像素$(x_k, y_{k+1})$, 并\begin{align}
        \begin{split}
          x_{k+1} &= x_k\\
          y_{k+1} &= y_k+1\\
          p1_{k+1} &= p1_{k} + 4a^2y + 2a^2\\
        \end{split}
      \end{align}
      \item 若$p1_k\geq 0$, 选择像素$(x_{k+1}, y_{k+1})$, 并\begin{align}
        \begin{split}
          x_{k+1} &= x_k - 1\\
          y_{k+1} &= y_k+1\\
          p1_{k+1} &= p1_{k} + 4a^2y + 2a^2 - 4b^2x\\
        \end{split}
      \end{align}
    \end{enumerate}
    \item 计算区域2的初始决策参数$$p2_0 = 2b^2(x^2+1)-4b^2x+2a^2(y^2+y-b^2) +a^2/2$$
    \item 当$b^2x\leq ^2y$且$x\geq 0$时, 为区域2, 逆时针移动, 不断进行如下迭代\begin{enumerate}
    \item 绘制点$(x,y)$
      \item 若$p2_k<0$, 选择像素$(x_k, y_{k+1})$, 并\begin{align}
        \begin{split}
          x_{k+1} &= x_k - 1\\
          y_{k+1} &= y_k+1\\
          p2_{k+1} &= p2_{k} - 4b^2x + 2b^2 + 4a^2y\\
        \end{split}
      \end{align}
      \item 若$p1_k\geq 0$, 选择像素$(x_{k+1}, y_{k+1})$, 并\begin{align}
        \begin{split}
          x_{k+1} &= x_k - 1\\
          y_{k+1} &= y_k\\
          p2_{k+1} &= p2_{k} - 4b^2x + 2b^2\\
        \end{split}
      \end{align}
    \end{enumerate}
    \item 之后首先沿x轴对称, 得到右半椭圆, 之后再沿y轴对称, 得到完整的椭圆, 最后使用之前求得的center坐标进行平移, 得到最终的绘制目标
  \end{enumerate}
  \item 我的理解\begin{enumerate}
    \item 优雅的代码: 使用lambda表达式, 1行一个变换, 利用python list的+=运算符, 简单地完成整个变换过程, 得到整个椭圆.
  \end{enumerate}
  \item 相关代码\begin{enumerate}
    \item 计算算法所需参数
    \begin{lstlisting}[language={Python}] 
      x0, y0 = p_list[0]
      x1, y1 = p_list[1]
      a = abs(x1 - x0) / 2
      b = abs(y1 - y0) / 2
      center = [round((x0 + x1)/2), round((y0 + y1)/2)]\end{lstlisting}
    \item 准备辅助量
    \begin{lstlisting}[language={Python}] 
      result = []
      x = round(a)
      y = round(0)
      taa = a * a
      t2aa = 2 * taa
      t4aa = 2 * t2aa
      tbb = b * b
      t2bb = 2 * tbb
      t4bb = 2 * t2bb
      t2abb = a * t2bb
      t2bbx = t2bb * x
      tx = x\end{lstlisting}
    \item 算法主体
    \begin{lstlisting}[language={Python}] 
      d1 = t2bbx *  (x-1) + tbb/2 + t2aa * (1-tbb)
      while t2bb * tx > t2aa * y:
          result.append((x, y))
          if d1 < 0:
              y = y + 1
              d1 = d1 + t4aa * y + t2aa
              tx = x - 1
          else:
              x =  x - 1
              y =  y + 1
              d1 = d1 - t4bb * x + t4aa * y + t2aa
              tx = x
      
      d2 = t2bb * (x*x +1) - t4bb*x+t2aa*(y*y+y-tbb) + taa/2
      while x>=0:
          result.append((x, y))
          if d2 < 0:
              x = x - 1
              y = y + 1
              d2 = d2 + t4aa * y - t4bb*x + t2bb
          else:
              x =  x - 1
              d2 = d2 - t4bb * x + t2bb\end{lstlisting}
    \item 对称与平移变换
    \begin{lstlisting}[language={Python}] 
      result += list(map(lambda x :(x[0],-x[1]), result))
      result += list(map(lambda x :(-x[0],x[1]), result))
      result = list(map(lambda x: (x[0] + center[0], x[1] + center[1]), result))\end{lstlisting}
  \end{enumerate}
\end{itemize}
\subsection{DDA算法绘制线段}
\begin{itemize}
  \item 算法介绍\\
  \item 算法流程
  \begin{enumerate}
    \item 
  \end{enumerate}
  \item 我的理解: 
  \item 相关代码
  \begin{lstlisting}[language={Python}] 
\end{lstlisting}
\end{itemize}
\subsection{DDA算法绘制线段}
\begin{itemize}
  \item 算法介绍\\
  \item 算法流程
  \begin{enumerate}
    \item 
  \end{enumerate}
  \item 我的理解: 
  \item 相关代码
  \begin{lstlisting}[language={Python}] 
\end{lstlisting}
\end{itemize}
\subsection{\dots}
\dots
		
\section{系统介绍}
\dots

\section{总结}
\dots

\bibliographystyle{plain}%
%"xxx" should be your citing file's name.
\bibliography{myref}

\end{document}